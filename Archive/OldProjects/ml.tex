\section{ML: MetaLanguage for Fun and Profit! (Well maybe just fun)}

In order to learn something its sometimes best to have an application. So with that in mind we are \textbf{not} going to Poke through Haskell documentation, Pascal, Racket or any other functional programming language which has already implemented the features we actually want to learn about. We are going to implement those features in ML!\footnote{I am paraphrasing and adapting this tutorial from a series of blog posts by post-doctoral student Jeremy Kun from the University of Chicago. The blog is very, very good and this was the easiest jump into a programming language I have ever experienced and that includes python. You can find more information regarding the blog in the references section.}  

\subsection{Why ML? (crickets)}

ML is great for what we want to use it for (learning category theory) for the following reasons:

\begin{itemize}
\item \textbf{Parametric Polymorphism}
\begin{itemize}
\item ML was the first language to explicitly recognize parametric polymorphism.
\item Parametric polymorphism just basically means that an operator will function in the same was no matter what kind (specifically type) of data we feed into our program. The types are effectively being considered as variables. 
\end{itemize}
\item \textbf{Type Inference}
\begin{itemize}
\item ML (as does Haskell) also contains an explicit type inference system!
\item What this means is that in both ML and Haskell your program will not compile unless the compiler directly proves it produces the correct type during every step of the programs functioning. 
\item One of the benefits of this type inference system is that it is impossible to run a program with a type error in it. When you try to run a program with a type error the compiler shows you the type it was expecting and the type it got instead.
\item This means that all your code errors will be of the more challenging conceptual variety! Yay!
\end{itemize}
\end{itemize}

\subsection{Preliminaries}

As with all good languages the compiler is free (as in both free beer and free software) accompanied by a modified BSD license. \\
You can download the compiler here: \\
\begin{verbatim}
    http://www.smlnj.org
\end{verbatim}

If you are using a mac you can simply use homebrew or macports to install the compiler by running the commands: \\
\begin{verbatim}
    brew update
    brew upgrade
    brew install sml
\end{verbatim}
SMLNJ is supported up to El Capitan, the latest distribution of OS X. 

If you are running a Linux box you can run the usual combination of apt-get to install the compiler. 

If you are using Windows, please consult the documentation.

The file extension for smlnj programs is ,sml .

\subsection{Baby Steps}

The differences in the ML syntax and operators are similar to most languages you might be used to but there are some unique particularities you should be aware of. It is highly recommended that you follow through enough introductory documentation to ensure that you know what those particulars are. 

\subsubsection{Variables}

We can declare a variable in ML globally in a few different ways.

The most basic way to declare a variable is directly one by one:

\begin{verbatim}
    val x = 5;
    val y = 4;
\end{verbatim}
Notice that each variable has a prefix of \textbf{val} (short for value) and is followed by a semicolon alerting the compiler that this line is ready to be evaluated. The semicolon is \textbf{only} used in this way.

We can also declare global variables on a single line by using the keyword (not operator, we will get to that in a moment) \textbf{`and'}:

\begin{verbatim}
    val x = 5 and y = 4;
\end{verbatim}

notice that we only had to write \textbf{val} and a semicolon one time each. 

In ML \textbf{`and'} is a keyword and only used for syntax based conjunctions of functions and variables. And is only necessary when the defined variables are dependent, or defined in terms of each other. 

You can also define variables using pattern matching in a tuple or ordered pair as follows:

\begin{verbatim}
    val (x, y) = (5, 4);
\end{verbatim}

\subsubsection{Types}

If you look at the way we defined our variables you will notice we never told the compiler what type of number 4 or 5 was. But the compiler does in fact know and the type stays with the variables for the duration of the run. We can see this if we run the variable declarations through the compiler and see what the Read, Eval, Print, Loop (REPL) output shows us:

\begin{verbatim}
    [opening lookVars.sml]
    val x = 5 : int
    val y = 4 : int
\end{verbatim}

The environment \textbf{int} or integer is printed out next to each variable for us to see. 

\subsubsection{Basic Operations}

ML has the four standard arithmetic operators defined over the integers of $+, -, *, \text{div}$. The negation operator is the tilde symbol $\simeq$. 

There is no need to define a temporary variable to hold the output of simple operations unless you want to keep them for later use. Meaning if you are using ML as a calculator there is a REPL construct called \textbf{it} which saves the last unbound expression which was evaluated. 

\begin{verbatim}
    -5 + 4;
    val it = -1 : int
\end{verbatim}

Floating point numbers in ML are called \textbf{real}. But there is no automatic type coercion in ML. To multiply an integer and a real number together you first have to convert the integer to a real number \emph{before} performing the operation. The compiler will not take care of the conversion for you it will give you an error. 

\begin{verbatim}
 1    - val x = 5.0;
 2    val x = 5.0 : real
 3    - val y = 4;
 4    val y = 4 : int
 5    - x * y; 
 6    stdIn: 5.1-5.6 Error: operator and operand don't agree [tycon mismatch]
 7    operator domain: real * real
 8    operand:            real * int
 9    in expression:
10        x * y
11    - x * Real.fromInt(y);
12    val it = 28.0 : real
\end{verbatim}

In line 11 of the above calculation we converted y to a real number by using the syntax: 
\begin{verbatim}
Real.fromInt(y)
\end{verbatim}
Where the integer to be converted is contained in parentheses after its initialized type \textbf{fromInt} has been stated. The prefix \textbf{Real} is the type we are casting the integer into. We are permitted to perform the type casting inline with the operation. 

\subsection{Booleans}


\section{More Realistic Syntax} 

Usually when we define some object in a global environment it is not going to be a variable it will be the name of a function or a test, and variables will be defined in the local environment. We use the syntax:
\begin{verbatim}
let ... in ... end
\end{verbatim}
To encapsulate these locally declared variables and evaluations. 

\begin{verbatim}
    let
        val x = 5
        val y = 4
    in
        (x + 3*y) div 2
    end
\end{verbatim}

There are two places the variables will come from in this expression:
\begin{itemize}
\item \textbf{Ambient Environment:} This environment contains the variables which were defined outside of our let statement. 
\item \textbf{Inside Environment:} This environment contains the variables which are defined inside of our let statement. In this case they are $x$ and $y$,
\end{itemize}

The variables declared in the \emph{inside} environment leave the scope of the \textbf{let} construction after they have been evaluated by \textbf{in} environment. When we take the \textbf{let} expression and evaluate it all together it is the same evaluation that results from evaluating the \textbf{in} expression. 

 